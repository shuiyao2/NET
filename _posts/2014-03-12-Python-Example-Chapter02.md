---
date: 2014-03-12 18:08:00+00:00
layout: post
title:  '[Python 标准库] 第二章 数据结构' 
categories: 读书笔记
tags: Python
---

#### Chapter 02 数据结构

##### 2.1 collections - 容器数据类型
作用：容器数据类型
2.1.1 Counter  
作为一个容器，用于跟踪相同的值增加了多少次。  

**初始化**  
1. 调用 Counter 的构造函数，提供元素序列或者包含键和计数的字典，
或者使用关键字参数将字符串名映射到计数。  
2. 构建空 Counter，然后通过 update() 方法填充。  

**函数**  
`elements()`：返回 Counter 的所有元素  
`most_common()`：返回包含 n 个最常遇到的输入值及其相应计数。  

**算术操作**  
Counter 实例支持算术和集合操作来完成结果的聚集。  
生成新的 Counter 时，计数为 0 或负数的元素都会被删除。  

2.1.2 defaultdict  

2.1.3 deque  
(双端队列)支持从任意一端增加和删除元素。  
**函数**  
`extend()`：从小到到大排序  
`extendleft()`：从大到到小排序  
`append()`：右端填充  
`appendleft()`：左端填充  
`pop()`：从右端删除一个元素  
`popleft()`：从左端删除一个元素  
`rotate(n)`：从右端取出 n 个元素放到左端  

2.1.4 namedtuple  
`namedtuple()`：创建 tuple ,参数为新类名和一个包含元素的名的字符串。
将 rename 设置为 True,可以对非法字段重命名。  

2.1.5 OrderedDict  
是字典的一个子类，用于记住其内容增加的顺序，
并在创建迭代器时使用这个顺序。还会考虑元素增加的顺序。  

##### 2.2 array - 固定类型数据序列
作用：高效管理固定类型数据的序列  
2.2.1 初始化  

2.2.2 处理数组  

2.2.3 数组与文件  

2.2.4 候选字节顺序  

##### 2.3 heapq - 堆排序算法
作用：heapq 模块实现了一个适合 Python 列表的最小堆排序算法。  
2.3.1  创建堆
`heappush()`和`heapify()`创建堆。  
使用`heappush()`时，从数据源增加新元素时会保持元素的堆顺序。  
如果数据已经在内存中，使用`heapify()`重新组织列表的元素会更高效。  

2.3.2 访问堆的内容  
`heappop()`：删除最小值的元素  
`heapreplace()`：删除现有元素并替换为新值  
`nlargest()`：查找范围内的最大值  
`nsmallest()`：查找范围内的最小值  

##### 2.4 bisect - 维护有序列表
作用：维护有序列表  
**函数**  
`insort()`：在现有值之后插入新值  
`insort_left()`：在现有值之前插入新值  

##### 2.5 Queue - 线程安全的 FIFO 实现
作用：提供一个线程安全的 FIFO 实现  
2.5.1 基本 FIFO 队列  
`put()`：将元素增加到序列一端  
`get()`：将元素从另一端删除  
`Queue()`：创建 FIFO (先进先出)顺序  
`LifoQueue()`：创建 LIFO (后进先出)顺序  
`PriorityQueue()`：使队列内容的有序顺序来决定获取哪一个元素  

##### 2.6 struct - 二进制数据结构
作用：在字符串和二进制数据之间转换  
**函数**  
`packing()`：使用格式指示符将数据打包为字符串  
`unpacking()`：字符串解包数据  
`pack_into()`和`unpack_from()`直接写入预分配的缓冲区  

2.6.1 struct 的字节序指示符  

##### 2.7 weakref - 对象的非永久应用
作用：引用一个对象，如果不再有其他非弱引用，
则允许用垃圾回收器回收其内存  


##### 2.8 copy - 复制对象
作用：提供函数用于浅副本或深副本语义复制对象  
**函数**  
`copy()`：浅复制，原对象内容的引用  
`deepcopy()`：深复制，原对象内容的复制  

#### 2.9 pprint - 美观打印数据结构
作用：美观打印数据结构  
